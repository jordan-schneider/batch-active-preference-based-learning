""" Runs the test set generated by post.py by generating fake reward weights and seeing how many
are caught by the preferences."""

from pathlib import Path
from typing import List, Optional

import argh  # type: ignore
import matplotlib.pyplot as plt  # type: ignore
import numpy as np
from argh import arg
from scipy.stats import multivariate_normal  # type: ignore

from post import filter_halfplanes


def normalize(vectors: np.ndarray) -> np.ndarray:
    """ Takes in a 2d array of row vectors and ensures each row vector has an L_2 norm of 1."""
    return (vectors.T / np.linalg.norm(vectors, axis=1)).T


def run_test(
    reward: np.ndarray,
    normals: np.ndarray,
    epsilon: float = 0.0,
    reward_noise: Optional[float] = None,
    n_rewards: Optional[int] = None,
    fake_rewards: Optional[np.ndarray] = None,
) -> float:
    """Runs an alignment test on randomly generated fake reward weights. """

    if reward_noise is not None and n_rewards is not None:
        dist = multivariate_normal(
            mean=reward, cov=np.eye(reward.shape[0]) * reward_noise
        )

        fake_rewards = normalize(dist.rvs(n_rewards))
    elif fake_rewards is None:
        raise ValueError(
            "Must specify either fake_rewards or reward_noise and n_rewards."
        )

    for fake_reward in fake_rewards:
        assert np.abs(np.linalg.norm(fake_reward) - 1) < 0.0001

    frac_pass = np.mean(np.all(np.dot(fake_rewards, normals.T) > epsilon, axis=1))

    return frac_pass


def run_epsilon_experiments():
    """ Run tests with full data to determine how much reward noise gets"""
    pass


# TODO


@arg("--noises", nargs="+", type=float)
@arg("--samples", nargs="+", type=int)
def run_tests(
    *,
    epsilon: float = 0.0,
    noises: List[float] = [1.0],
    samples: List[int] = [1],
    n_rewards: int = 100,
    datadir: Path = Path("preferences"),
):
    """ Runs multiple tests with different of fake reward noises and sample sizes."""
    true_reward = np.load(datadir / "reward.npy")
    normals = np.load(datadir / "psi.npy")
    preferences = np.load(datadir / "s.npy")

    normals = (normals.T * preferences).T

    for sample in samples:
        filtered_normals, _ = filter_halfplanes(
            normals=normals[:sample], n_samples=1000, epsilon=epsilon,
        )

        frac_passes = np.array(
            [
                run_test(
                    normals=filtered_normals,
                    reward=true_reward,
                    epsilon=epsilon,
                    reward_noise=noise,
                    n_rewards=n_rewards,
                )
                for noise in noises
            ]
        )

        assert np.all((frac_passes <= 1.0) & (frac_passes >= 0.0))
        # print(frac_passes)

        plt.plot(np.log(noises), frac_passes, label=sample)
    plt.title(f"Pass rate of {n_rewards} reward functions vs variance")
    plt.xlabel("Variance of Guassian Generating Rewards")
    plt.ylabel("Pass rate of Rewards")
    plt.ylim((0, 1))
    plt.legend()
    plt.savefig("results.png")


if __name__ == "__main__":
    argh.dispatch_commands([run_test, run_tests])
